\section{\hei{2013-2014第一学期总结和下学期计划}}

\subsection{\hei{主要的工作}}

\par{这学期的主要和张维师兄,周坤一起做循环分割的开发工作和测试,进一步完善循环分割工具的功能.由于一开始基础比较薄弱,对于llvm中的很多东西很陌生,碰到一个问题,需要花费很多时间在调研上,所以解决每个问题都花费了很多时间.虽然在过程中遇到各种各样的难题,但是在老师和师兄们的指导下,都一一解决,积累下来的知识和经验对我有很大的帮助.下面是具体的内容:}
\par{一开始在张维师兄搭建的框架和基本功能上,我们进一步测是并完善.}

\begin{itemize}
\item{对于循环分割,我们只需要分割顶层循环,如果直接使用TraverseForStmt遍历ForStmt会得到所有的loop,这样不符合我们的要求.所以一开始调研了clang前端访问AST的基本方法,还是采用了TraverseForStmt的方法,遍历整个AST树,当到达某个节点时会调用相应的方法进行对这个节点的访问(访问的内容可有用户规定,例如dump节点的内容,默认情况下是直接返回不进行其他操作.),但是对于它的访问方式做了一下改变,用ForAction来规定访问模式.当访问到ForStmt时,默认是继续ForStmt节点下的Init,Cond,Inc,ForBody,我们通过改写VisitForStmt,并用ForAction判断遍历的模式,ForAction==1时,说明找到ForStmt,直接返回,不接着向下访问.获取到的ForStmt保存在TopLevelLoop数组中.为后续的处理做准备.}

\item{对于循环分割,我们分割时并不是所有的循环都要分割,需要根据条件进行分割,在分割是我们,有用户指定相应的循环分割的下限,低于这个下线的我们不做分割,但是对于判断循环分割的次数存在很多因素,有的可能不能判断循环分割的次数,在这里我们保守性的处理,现在只能判断简单的类型,如for(i=0;i<100;i++;)或for(i=0,j=0;i<50\&\&j<20;i++,j++)这种判断的模式很局限,只能对于特定模式进行判断.中间花费了一段时间调研但是对于怎么实现归纳变量分析,还是存在许多疑问.TODO:需要对归纳变量分析,获得相对精确的判断方法.}

\item{之后主要是解决测试中发现的问题,第一个关于数组的问题,在for循环中出现sizeof(array),当作为参数传入被调用的函数时,array就会当作一个指针来处理,这样就会改变了原来的语义,导致程序运行的结果有错误.解决这个问题的策略,是在收集参数前,对于数组进行判断,获得表示array大小的变量或是值,若是变量的话也当作参数传入,将for中的sizeof(array),改成:sizeof(elementType)*(*n)或sizeof(elementType)*100.
     
     在替换变量的时候,会将所有字符串中出现的与变量名相同的字符串给地换掉,所以在替换的时候收集出现在引用中的变量名字,并记录他们的位置,保证在替换时,不做替换.

     return替换时也会出现类似的问题,return的替换是按照前面收集到的循环中出现return的次数来替换的,测试中发现,return出现在,引用或是注释中,后面需要替换的return并没有替换,导致错误的出现.修改的策略和前面的类似,首先收集引用和注释的位置,当匹配到return时,判断是否出现在这些位置中间,若在,则跳过不替换.
     }


\item{循环分割,构造被调用的函数时,是通过从源文件中提取代码,一开始提取的方式,是通过编译过程中保存的位置信息获得的,只是从行信息出发获得相应的代码段.但是后来在测试中发现,只是从行信息获取时,跟实际想获得的代码存在误差,误差的来源是对于代码的格式考虑的不是很周全,以为通过行信息获取代码段时,如果代码段最后一行存在注释,提取时会将最后一行的注释一并提取出来.从而导致分割后出现错误.
     
     为了解决相应的问题,想从行列信息获得代码,但是由于clang,SourceRange获得的位置信息,是以Token为单位给的,对于一个标识符,它的开始位置和结束位置,都是标识符对应的Token的第一个字符,而我们想从这样的行列信息获得代码显然是有错误的.对于这种问题做了保守性的处理,还是从获得行列信息出发,只是在到达最后一行时,增加了一个对注释的判断条件,在获得最后一行时,判断'/*',只提取'/*'前的部分,这样做只能保证暂时不会出现这样的问题,还需要进一步的解决.对此我们需要获取准确行列位置信息,需要从词法分析阶段,获取需要的信息.
     
     
      关于对Lexer的调研,从获得位置信息SourceLocation,获得相应Token,并通过clang::Lexer::getLocForEndOfToken获得对应Token的结束位置,还有一种情况,对于宏来说,这个函数获取的位置信息是不准确的,所以在getLocForEndOfToken前,先对SourceLocation用getExpansionRange获得宏结束的位置,对于不是宏的位置,开始结束位置是一样的,这样可以获得语句最后一个标识符的结束位置,再由SourceLocation获取指向这个位置的指针,判断后面';'的位置,这样的处理可以得到相对精确的位置.

      
\begin{lstlisting}
//获得语言的类型.
const LangOptions &Lang = context.getLangOpts()

SourceManager &SM = context.getSourceManager();
SourceLocation End = SR.getEnd();//得到一个语句最后一个标识符

//如果是宏,获得到宏开始和结束的位置
const std::pair<SourceLocation,SourceLocation> ExpansionLoc(SM.getExpansionRange(End));
const SourceLocation Ebegin = ExpansionLoc.first;

//宏结束的位置,宏中最后一个标识符位置
const SourceLocation EEnd = ExpansionLoc.second;

//得到最后一个标识符的长度
SourceLocation EndLoc(clang::Lexer::getLocForEndOfToken(EEnd, 1, SM, Lang));

bool Invalid = false;
//得到指向给定位置的指针
const char *EEndptr = SM.getCharacterData(EndLoc,&Invalid);
\end{lstlisting}

     }

\item{另一个问题是关于宏的处理,循环用到宏,我们需要在新的.c文件中,重新定义需要的宏(按照源文件中定义宏的方式),不能放到头文件中,也不能将源文件中宏给提取出来,因为代码中,宏的定义和取消,跟位置顺序有很大的关系.需要做的是,找到源文件中宏,根据位置信息,获得宏的定义,并在定义和取消定义前,判断这个宏是否定义过.
     
     因为宏的处理是在预处理阶段,通过一段时间的调研,预处理的信息都保存在preProcessor中,类preProcessor可以,从前端实例CompilerInstance \&CI获得,起初由于查找方法的原因,找到的宏的信息并不完整,只能找到最有一个定义的地方,关于同名的其他的宏,没有收集到相关的信息.查找宏的迭代器typedef llvm::DenseMap<const IdentifierInfo *, MacroDirective*>::const\_iterator macro\_iterator,TODO:不是通过IdentifierInfo找MacroInfo,而是直接MacroDirective类直接获得宏,再由接口MacroDirective *getPrevious(),得到具有相同名字的宏.然后从MacroDirective类出发,得到文件中所有的宏(不包括文件外的),然后的到源代码的位置以及源代码并保存在MacroInFile等数组中.
     
     在得到宏的信息后,后面就是写到文件中,由于宏的定义跟位置有关系,所以在写入到新的.c文件时,是根据位置先后顺序写入的,保证了被调用函数用到的宏和源代码同样的定义.     
}


\end{itemize}

\subsection{\hei{收获与不足}}
\par{收获}
\par{主要的收获,收获的学习的方法,增加了解决问题的能力,以前对于项目方面的工作经验很是缺乏,经过这学期老师和师兄的指导,自己调研解决问题的能里逐步提高,在测试中积累经验,对于编译器方面有了更深入的了解,对于编程的能力也有所提高.然后在工作中自己发现问题,通过自己调研和老师的指导,解决问题,过程中学到了很多知识,也对问题有了很深入的理解.}

\par{不足}
\begin{itemize}

\item{虽然现在能编写一些代码,但自己编程方面的能力还有待提高,在工作中发现,编写代码是一方面,但更重要的是在于算法思想和相关的理论知识,自己可能在这一方面还很薄弱,以后需要多看点论文和算法.}

\item{经过一个学期的学习,发现考虑问题的时候不是很全面彻底,遇到问题时,针对这个问题出现原因,提出相应的解决方案,但是这个问题在另一种情况下又会出现,还需要重新改写方案和代码,这样不仅耗时而且还没有找到一个很好的解决方案,结果差强人意.在解决上上述问题的时候尤为明显,耗费了很多时间.这方面以后需要重视起来,动手做之前,做好充分的调研和思考.}

\end{itemize}

\subsection{\hei{计划}}

1) 由于循环分割工具的功能不是很完善,现在解决的策略考虑的不够全面,还有很多方面需要继续测试,准备下学期继续,找个测试例子进行测试并进一步完善.

2)前段时间用别的例子测了一下,还存在寄存器变量的问题,寄存器变量不能用指针传入到被调用的函数,还需要进一步寻找解决的方案.


2)发现自己在基础知识方面还是很缺乏,准备后面多看一些算法的书籍(如算法导论)和论文.
